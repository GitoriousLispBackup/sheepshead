Sheepshead - A Card Game
========================
Michael McDermott <mmcdermott@mad-computer-scientist.com>

Introduction
------------

Sheepshead is a German-American game played mostly in Wisconsin and
Minnesota. Outside of this geographic region, few people seem to
recognize it. As such, there are very few video game implementations
available and even fewer that run on good old Linux. The available
options are:

* Yahoo! Games. Maybe my reason for discounting it will sound like
  sour grapes, but I was unable to ever play a game. When I joined a
  table, the owner always booted me and when I opened a table, no one
  joined.
* schafKopf. This game has not been updated to KDE/Qt4 and does not
  seem to have any recent activity. Finally, when I went to the effort
  to dredge up KDE 3 libraries, it turned out to be quite different
  than the game I learned and loved.
* A couple of shareware options for Windows. Need I say more?

Our objectives are to create a Sheepshead game with the following
properties:

. The rules I grew up with (more on this later).
. Platform independence. At the very least, Windows and Linux. If a
Mac owner comes along, I would love to test for that platform as well.
. Core/UI separation. Eventually, multiple front ends would be ince.
In the immediacy, a simple Q/A-like console version will suffice.
. AI players.

This really does not seem like too much to ask for.

The rules we will be implementing can be found at Pagat
footnote:[http://www.pagat.com/schafk/shep.html]. The only major
caveat is that we will be implementing the Jack of Diamonds variant.

Core
----

This is where we model the basic elements of the game, including the
game itself. The interface should do little more than advance and
display the game in its own fashion. 

A Nice Game of Cards
~~~~~~~~~~~~~~~~~~~~

We will start at the bottom and build up. What is the most fundamental
thing in a card game? The cards. You cannot play without them, either
digitally or physically. The deck in Sheepshead is A-7 (i.e. 2-6s are
discarded) of each suit (assuming a French deck: clubs, spades,
hearts, and diamonds).

<<core.lisp>>=
(in-package :sheepshead)

(defconstant +LOWCARD+ 7)
(defconstant +HIGHCARD+ 14)

(defclass card ()
    ((rank :accessor rank :initarg :rank)
     (suit :accessor suit :initarg :suit)))
@

Suits are assumed to be members of +'(:clubs :spades :hearts
:diamonds)+.
Rank must be between 7 and 14, inclusive. The card
corresponding to each number will start at 7 and follow the Germanic
ordering that Sheepshead uses. So, the following numbers would
correspond to the following cards:

.Card constants
|==============================
|Constant | Card
|7        | 7
|8        | 8
|9        | 9
|10       | King
|11       | 10
|12       | Ace
|13       | Jack
|14       | Queen
|==============================

The ordering may seem a little strange, but it should make sense with
knowledge of the rules because it allows rank comparison to be done
purely as +rank1 > rank2+. 

We will add an implementation of +print-object+ (See section 28.2 of
Common Lisp the Language; the equivalent of overriding C#'s toString()
method). Clearly, this will not suffice for the UI, but it will make
things much, much easier when debugging interactively.

<<core.lisp>>=
(defmethod print-object ((card card) stream)
    (let ((name (case (rank card)
                    (7 "7")
                    (8 "8")
                    (9 "9")
                    (10 "KING")
                    (11 "10")
                    (12 "ACE")
                    (13 "JACK")
                    (14 "QUEEN"))))
    (format stream "#<CARD ~A OF ~A>" name (suit card))))
@

This is little better than a C-struct in its current form. We have not
even bound the members. That is all right though. We will write a
function to generate a Sheepshead deck. The method used will be
extremely straightforward. For each suit, we will generate each of the
cards in the range 7-14. 

<<core.lisp>>=
(defmethod generate-deck ()
    (let ((deck (make-array '(32)))
          (index 0))
        (loop for suit in '(:clubs :spades :hearts :diamonds)
            do 
                (loop for rank from +LOWCARD+ upto +HIGHCARD+
                    do 
                    (setf (aref deck index) (make-instance 'card :rank rank :suit suit))
                    (setf index (+ index 1))
                    ))
         deck
    ))
@

We will provide another function, this one to shuffle the deck. The
algorithm used will be the Fisher-Yates Algorithm
footnote:[http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle].
From the above source, the pseudocode is:

    To shuffle an array a of n elements:
       for i from n - 1 downto 1 do
             j <- random integer with 0 <= j <= i
             exchange a[j] and a[i]

Our function will operate on an array, for efficiency's sake.
Accessing an array, in lisp, is constant time, but accessing the Nth
element of a list is O(n) time. So, to implmenet the above algorithm:

<<core.lisp>>=
(defmethod shuffle-deck ((deck array))
    (let ((deck-size 32))
        (loop for index from (- deck-size 1) downto 1
            do
                (let* ((random-index (random index))
                       (temp (aref deck random-index)))
                    (setf (aref deck random-index) (aref deck index))
                    (setf (aref deck index) temp)
                    ))
         deck
        ))
@

Players
~~~~~~~

With a shuffled pack of cards, the next step is to deal. To deal, we
need to have a game on, and to have a digital game on, we need to
model the game. So, let us do that.

Any player, regardless of whether they are human or AI controlled will
have a name, a hand, and a score (the game's running score, not the
points scored in a single hand).

<<core.lisp>>=
(defclass player ()
    ((name :accessor name :initarg name :initform "Foo")
     (hand :accessor hand :initarg hand :initform nil)
     (score :accessor score :initform 0)
    ))
@

Another basic is that all players must be able to return their card
selection for a given trick. While this function must be present, the
method chosen to pick the card will differ. For a player, the card
must be selected through the UI. For a bot, the card must be picked
using the proper algorithm.

<<core.lisp>>=
(defgeneric play-card (player trick))

(defgeneric take-blind? (player))
@

==== Human Controlled ====

A human controlled player will be like the basic one above in all
respects, save one. Namely, that its +play-card+ implementation must
get an answer from the UI. The easiest way to do this without tying
ourselves to any one is to provide a callback as a slot, and call it
when +play-card+ is called.

<<core.lisp>>=
(defclass human-player (player)
    ((play-callback :accessor play-callback :initarg play-callback)
     (blind-callback :accessor blind-callback :initarg blind-callback)
     ))

(defmethod play-card ((player human-player) trick)
    (funcall (play-callback player) trick))

(defmethod take-blind? ((player human-player))
    (funcall (blind-callback player)))
@

==== Bots ====

This is the problem with trying to write an artificial intelligence
for a game I've played almost as long as I can remember: I don't
really think much about why I play as I do. A lot of it revolves
around 

=== Games ===

We have cards and players. It is time to put it all together and play
a game.

Interfaces
----------

The interface in this first version will be simple. Extremely simple.
Almost childishly simple.

Packaging
---------

Like most Lisp systems, we will pacakge Sheepshead with ASDF. The
package should be straightforward.

<<sheepshead.asd>>=
(defpackage #:sheepshead
    (:export card)
    (:use :cl :asdf))

(defsystem sheepshead
    :version 0.1
    :author "Michael McDermott"
    :license "BSD"
    :description "Sheepshead"
    :components ((:file "core")))
@

Conclusion
----------

Index
-----
