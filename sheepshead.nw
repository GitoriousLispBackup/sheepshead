Sheepshead - A Card Game
========================
Michael McDermott <mmcdermott@mad-computer-scientist.com>

Introduction
------------

Sheepshead is a German-American game played mostly in Wisconsin and
Minnesota. Outside of this geographic region, few people seem to
recognize it. As such, there are very few video game implementations
available and even fewer that run on good old Linux. The available
options are:

* Yahoo! Games. Maybe my reason for discounting it will sound like
  sour grapes, but I was unable to ever play a game. When I joined a
  table, the owner always booted me and when I opened a table, no one
  joined.
* schafKopf. This game has not been updated to KDE/Qt4 and does not
  seem to have any recent activity. Finally, when I went to the effort
  to dredge up KDE 3 libraries, it turned out to be quite different
  than the game I learned and loved.
* A couple of shareware options for Windows. Need I say more?

Our objectives are to create a Sheepshead game with the following
properties:

. The rules I grew up with (more on this later).
. Platform independence. At the very least, Windows and Linux. If a
Mac owner comes along, I would love to test for that platform as well.
. Core/UI separation. Eventually, multiple front ends would be ince.
In the immediacy, a simple Q/A-like console version will suffice.
. AI players.

This really does not seem like too much to ask for.

The rules we will be implementing can be found at Pagat
footnote:[http://www.pagat.com/schafk/shep.html]. The only major
caveat is that we will be implementing the Jack of Diamonds variant.

Core
----

This is where we model the basic elements of the game, including the
game itself. The interface should do little more than advance and
display the game in its own fashion. 

A Nice Game of Cards
~~~~~~~~~~~~~~~~~~~~

We will start at the bottom and build up. What is the most fundamental
thing in a card game? The cards. You cannot play without them, either
digitally or physically. The deck in Sheepshead is A-7 (i.e. 2-6s are
discarded) of each suit (assuming a French deck: clubs, spades,
hearts, and diamonds).

[source,lisp]
<<core.lisp>>=
(in-package :sheepshead)

(defconstant +LOWCARD+ 7)
(defconstant +HIGHCARD+ 14)
(defconstant +VERSION+ 0.1)
(defconstant +MINPLAYERS+ 3)
(defconstant +MAXPLAYERS+ 5)
(defconstant +DECKSIZE+ 32)

(defclass card ()
    ((rank :accessor rank :initarg :rank)
     (suit :accessor suit :initarg :suit)))
@

Suits are assumed to be members of +'(:clubs :spades :hearts
:diamonds)+.
Rank must be between 7 and 14, inclusive. The card
corresponding to each number will start at 7 and follow the Germanic
ordering that Sheepshead uses. So, the following numbers would
correspond to the following cards:

.Card constants
|==============================
|Constant | Card
|7        | 7
|8        | 8
|9        | 9
|10       | King
|11       | 10
|12       | Ace
|13       | Jack
|14       | Queen
|==============================

The ordering may seem a little strange, but it should make sense with
knowledge of the rules because it allows rank comparison to be done
purely as +rank1 > rank2+. 

We will add an implementation of +print-object+ (See section 28.2 of
Common Lisp the Language; the equivalent of overriding C#'s toString()
method). Clearly, this will not suffice for the UI, but it will make
things much, much easier when debugging interactively.

[source,lisp]
<<core.lisp>>=
(defmethod print-object ((card card) stream)
    (let ((name (case (rank card)
                    (7 "7")
                    (8 "8")
                    (9 "9")
                    (10 "KING")
                    (11 "10")
                    (12 "ACE")
                    (13 "JACK")
                    (14 "QUEEN"))))
    (format stream "~A OF ~A" name (suit card))))
@

This is little better than a C-struct in its current form. We have not
even bound the members. That is all right though. We will write a
function to generate a Sheepshead deck. The method used will be
extremely straightforward. For each suit, we will generate each of the
cards in the range 7-14. 

[source,lisp]
<<core.lisp>>=
(defmethod generate-deck ()
    (let ((deck (make-array (list +DECKSIZE+) 
                            :fill-pointer +DECKSIZE+))
          (index 0))
        (dolist (suit '(:clubs :spades :hearts :diamonds))
            (loop for rank from +LOWCARD+ upto +HIGHCARD+
                do 
                (setf (aref deck index) (make-instance 'card :rank rank :suit suit))
                (setf index (+ index 1))
                ))
         deck
    ))
@

We will provide another function, this one to shuffle the deck. The
algorithm used will be the Fisher-Yates Algorithm
footnote:[http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle].
From the above source, the pseudocode is:

    To shuffle an array a of n elements:
       for i from n - 1 downto 1 do
             j <- random integer with 0 <= j <= i
             exchange a[j] and a[i]

Our function will operate on an array, for efficiency's sake.
Accessing an array, in lisp, is constant time, but accessing the Nth
element of a list is O(n) time. So, to implmenet the above algorithm:

[source,lisp]
<<core.lisp>>=
(defmethod shuffle-deck ((deck array))
    (loop for index from (- +DECKSIZE+ 1) downto 1
        do
            (let* ((random-index (random index))
                   (temp (aref deck random-index)))
                (setf (aref deck random-index) (aref deck index))
                (setf (aref deck index) temp)
                ))
     deck)
@

Players
~~~~~~~

With a shuffled pack of cards, the next step is to deal. To deal, we
need to have a game on, and to have a digital game on, we need to
model the game. So, let us do that.

Any player, regardless of whether they are human or AI controlled will
have a name, a hand, and a score (the game's running score, not the
points scored in a single hand).

[source,lisp]
<<core.lisp>>=
(defclass player ()
    ((name :accessor name :initarg :name :initform "Foo")
     (hand :accessor hand :initarg :hand :initform nil)
     (dealer? :accessor dealer? :initarg :dealer? :initform nil)
     (score :accessor score :initarg :score :initform 0)
    ))
@

Another basic is that all players must be able to return their card
selection for a given trick. While this function must be present, the
method chosen to pick the card will differ. For a player, the card
must be selected through the UI. For a bot, the card must be picked
using the proper algorithm.

[source,lisp]
<<core.lisp>>=
(defgeneric play-card (player trick))
(defgeneric take-blind? (player))
(defgeneric bury (player blind))
@

==== Human Controlled ====

A human controlled player will be like the basic one above in all
respects, save one. Namely, that its +play-card+ implementation must
get an answer from the UI. The easiest way to do this without tying
ourselves to any one is to provide a callback as a slot, and call it
when +play-card+ is called.

[source,lisp]
<<core.lisp>>=
(defclass human-player (player)
    ((play-callback :accessor play-callback :initarg play-callback)
     (blind-callback :accessor blind-callback :initarg blind-callback)
     (bury-callback :accessor bury-callback :initarg bury-callback)
     ))

(defmethod play-card ((player human-player) trick)
    (funcall (play-callback player) trick))

(defmethod take-blind? ((player human-player))
    (funcall (blind-callback player)))

(defmethod bury ((player human-player) blind)
    (funcall (bury-callback player) blind))
@

==== Bots ====

This is the problem with trying to write an artificial intelligence
for a game I've played almost as long as I can remember: I don't
really think much about why I play as I do. A lot of it revolves
around evaluating my own hand, watching other players' play, and
making deductions. Later on, I would like to program an AI that takes
advantage of information has it is revealed during the course of the
game--perhaps even tracking the other players' tendencies. 

For now, we are going to keep this very simple.

=== Games ===

We have cards and players. It is time to put it all together and play
a game. Sheepshead game goes through the following phases:

. Play a hand:
.. Pass deal to the left.
.. The cards are dealt to each player.
.. Starting at the dealer's left, each player is given the chance to
take the blind.
.. If a player takes the blind, he may bury a number of cards
equivalent to the size of the blind..
.. Tricks begin. The first trick is opened by the player to the
dealer's left.
.. Once all tricks have been played, the number of points is tallied
for each team.
. If the provided number of game points has not been reached, go to
step #1.

[source,lisp]
<<core.lisp>>=
(defclass game ()
    ((players :initarg :players :accessor players :initform nil)
     (goal-points :initarg :goal-points :accessor goal-points :initform 0)
     (hands :initarg :hands :accessor hands :initform nil)
     ))
@

A game, then, can be simulated with a very simple method. We will
first check the number of players. While some people claim that you
can play Sheepshead with less than three or more than five players,
they are wrong--they are heretics, may they be burnt at the stake. A
valid game will have 3-5 players, and will play the Jack of Diamonds
variant when five are playing.

The top level game, then, will follow this basic format:

. Verify that the number of players provided is accurate.
. Play a hand.
. Compare scores. If the game is over, return the winning player. If
not, go back to #1.

Items 2-3 of the above list find their implementation here. Pretty
much, we indefinitely play hands until the game's target has been
reached. A target number of points of 0 indicates that the game has no
preplanned end, even though all good things must come to an end. 

[source,lisp]
<<core.lisp>>=
(defmethod play-game ((game game))
    (do-if-player-count-valid (length (players game))
        (do ()
            ((game-over? game))
            (play-hand game))))
@

We noted the conditions for a game's ending above. A succinct way of
stating the requirement is that if the target number of points for the
game is not 0 (i.e. the game is infinite) and at least one player has
as many or more points than the target, the game is over. We express
this succinctly in the method +game-over?+.

[source,lisp]
<<core.lisp>>=
(defmethod game-over? ((game game))
    (if (eq (goal-points game) 0)
        nil
        (reduce #'(lambda (x y) (or x y))
                (mapcar #'(lambda (player) 
                            (>= (score player) (goal-points game)))
                        (players game))
                :initial-value nil)
    ))
@

The basic structure of a game is now intact. The next step is to
implement the various stages pursuant of playing a hand in the
imaginatively named method +play-hand+.

[source,lisp]
<<core.lisp>>=
(defmethod play-hand ((game game))
    (setf (players game) (rotate-left (players game)))
    (setf (dealer? (first (players game))) t)

    (let ((blind (deal-hands (players game))))
        (let ((taker (take-round (rotate-left (players game)))))
            (unless (null taker)
                (bury taker blind)))
        ))
@

==== The Deal ====

The function +deal-hands+ generates a new deck, shuffles it, and deals
a hand to each player. It returns the blind and assumes that the first
player listed is the dealer. +deal-hands+ must do the following
things:

. Generate a deck.

. Shuffle the deck.

. Initialize each player's hand to be an empty array of the proper
size.

. Deal all of the cards out to the players and blind.

. Return the blind.

The reason that the players need not be returned is that they will be
modified during the function call.

[source,lisp]
<<core.lisp>>=
(defun deal-hands (players)
    (let ((deck (shuffle-deck (generate-deck)))
          (blind (make-array (list (blind-size (length players)))
                             :fill-pointer 0))
          (hand-size (hand-size (length players)))
          (blind-size (blind-size (length players))))
        (dolist (player players)
            (setf (hand player) 
                  (make-array (list hand-size)
                              :fill-pointer 0)
                  ))
        (dotimes (index hand-size)
            (unless (>= (fill-pointer blind) blind-size)
                (vector-push (vector-pop deck) blind))
            (dolist (player players)
                (vector-push (vector-pop deck) (hand player))
                ))
        blind
        ))
@

==== The Auction ====

I do not really know that auction is the correct term here. To be
sure, I do not even know what the correct term might be, but since
this word is used for the equivalent phase of the game in Bridge and
Skat, it seemed as good a choice as any.

The auction, as it is, consists of giving each player the opportunity
to take the blind, starting with the first player from the dealer's
left. We will simulate this phase in the function +take-round+. The
function itself will not be responsible for determining whether or not
a given player will take the blind. Rather, this responsibility will
be delegated to the +take-blind?+ method of the player.

If a player takes the blind, their +role+ slot will be updated
accordingly, and they will be returned. If no one takes the blind,
+nil+ will be returned.

[source,lisp]
<<core.lisp>>=
(defun take-round (players)
    (if (null players)
        nil
        (let ((decision (take-blind? (car players))))
            (if decision
                (car players)
                (take-round (cdr players))
                ))
    ))
@

==== Burying ====

The player who takes the blind may bury two cards (as points) up
front. As with other decision making processes, the precise method
used is delegated to the specific subclass of +player+ and its +bury+
method.

==== Tricks ====

Once the taking has or has not occurred, the main portion of the game
starts. The player to the dealer's left leads off the first trick and
the winner of each trick thereafter begins the next.

==== Scoring ====

The scoring happens on two levels, each occurring after the end of the
hand. Those two levels are scoring the hand (and, by extension,
determining the winner(s)) and scoring the game.

=== Utilities ===

The blind size, as indicated above, varies with the number of players
in the game. The rule of thumb is that it is the number of cards
remaining after all the players have been dealt the maximum number of
cards while having equal sized hands. Since there are only three
values, it is far easier to drop them somewhere (a function, in this
case) than it is to manually recalculate them. The table looks like
this:

.Blind sizes
|==============
|Players | Cards in the blind
|3       | 2
|4       | 4
|5       | 2
|==============

The only other thing to consider is when the number of players
provided is invalid. In this case, we signal an error.

[source,lisp]
<<core.lisp>>=
(defun blind-size (player-count)
    (do-if-player-count-valid player-count
        (case player-count
            (3 2)
            (4 4)
            (5 2))
    ))
@

Another comparable function is +hand-size+, which also takes a single
integer parameter indicating the number of players.

[source,lisp]
<<core.lisp>>=
(defun hand-size (player-count)
    (do-if-player-count-valid player-count
        (case player-count
            (3 10)
            (4 7)
            (5 6))
        ))
@

In several places, we perform an action only if the number of players
is accurate. This is done to prevent any strange bugs from either
conscious manipulation of the gamestate or from errors in the front
end. Because we use this several times, we will wrap it up in a nice
little macro.

[source,lisp]
<<core.lisp>>=
(defmacro do-if-player-count-valid (count &body body)
    `(if (valid-player-count? ,count)
        (progn ,@body)
        (error "There must be 3-5 players. ~A provided." ,count)
        ))
@

Often, we find ourselves checking the number of players. A quick
little utility function makes this much easier. +valid-player-count?+
ensures that the number passed to it is:

. An integer.
. Between the minimum number of players (3) and the maximum number of
players (5) inclusive.

[source,lisp]
<<core.lisp>>=
(defun valid-player-count? (player-count)
    (and (integerp player-count)
         (>= player-count +MINPLAYERS+)
         (<= player-count +MAXPLAYERS+)))
@

As seen above, we use rotation a great deal. That is because in a real
card game, the same things rotate. The definitions are here
(google-inspired, to be sure):

[source,lisp]
<<core.lisp>>=
(defun rotate-left (some-list)
    (concatenate 'list (cdr some-list) (list (car some-list))))

(defun rotate-right (some-list)
    (concatenate 'list (last some-list) (butlast some-list)))
@

Packaging
~~~~~~~~~

Like most Lisp systems, we will pacakge Sheepshead with ASDF. The
package should be straightforward.

<<sheepshead.asd>>=
(defpackage #:sheepshead
    (:export game player human-player card hand name
             +VERSION+ +MINPLAYERS+ +MAXPLAYERS+
             valid-player-count?)
    (:use :cl :asdf))

(defsystem sheepshead
    :version 0.1
    :author "Michael McDermott"
    :license "BSD"
    :description "Sheepshead"
    :components ((:file "core")))
@

Interfaces
----------

One of the primary objectives of this package was to allow plug 'n
play interfaces. So, there is no one single interface--except for now,
when I will implement only a single interface. The rest are strictly
TODO.

Console
~~~~~~~

The console interface is the simplest possible. It is to be the
Sheepshead equivalent of what happens when you type +gnuchess+ at the
command line. A simple, prompt-based interface. No ncurses, no
windowing, just a simple print out of game events and prompts for
input.

In the future, we will use libraries for other front ends (especially
the GUI). In order to prevent unneeded dependencies between them (i.e.
so that one could install the console version of sheepshead on a
headless box), we will keep the interface code in separate packages.

==== Initialization ====

We are going to create a simple +main+ function to kick everything
off. This will also serve as the entry point for +buildapp+ when we
create a binary.

The MO for this interface will be to:

. Print a welcome banner.
. Get player options and initialize the corresponding objects.
. Set up functions to handle game events.
. Let the game run itself.

We can then put all of these pieces together, like so:

[source,lisp]
<<consoleui.lisp>>=
(in-package #:sheepshead-consoleui)

(defun main ()
    (let ((game (make-instance 'sheepshead:game)))
        <<print banner>>
        <<initialize players>>
        <<wire up callbacks>>
        <<turn control over to game>>
        ))

<<utility functions>>
@

To identify ourselves, we will print a nice little welcome banner. As
gaudy as you can get in plain text.

[source,lisp]
<<print banner>>=
(format *standard-output* "Sheepshead version ~A~%Copyright 2010 by Michael McDermott~%~%" sheepshead:+VERSION+)
@

==== Initialize Players ====

To initialize the players, we need to get the number of players that
will be playing and set any other options (in this case, those options
are name and human vs. CPU control).

[source,lisp]
<<initialize players>>=
(let* ((player-count (get-integer "~&Please enter the number of players (3-5): " :test-fn #'sheepshead::valid-player-count?))
       (player-list nil))
    (dotimes (index player-count)
        (let ((control-choice (get-integer (format nil "~%Should player ~A be: ~%1.  Human-controlled~%2.  AI~%> " (1+ index)) :test-fn #'(lambda (x) (and (>= x 1) (<= x 2)))))
              (player-name (get-player-name index)))
            (case control-choice
                (1 (let ((player (make-instance 'sheepshead:human-player :name player-name)))
                        <<wire up callbacks>>
                        (push player player-list)))
                (2 (let ((player (make-instance 'sheepshead:bot-player :name player-name)))
                        (push player player-list)))
             )))
    (setf (sheepshead:players game) player-list))
@

<<wire up callbacks>>=
(setf (sheepshead:play-callback player) #'play-prompt)
(setf (sheepshead:bury-callback player) #'bury-prompt)
(setf (sheepshead:blind-callback player) #'blind-prompt)
@

The function +get-integer+ is separated out to keep the code nice and neat.
It doesn't really do anything surprising, just print out a prompt, read in
the data, and verify that it is valid. If the input read in is not a valid
integer, the prompt will be repeated until a valid answer is given.

[source,lisp]
<<utility functions>>=
(defun get-integer (prompt &key (test-fn nil))
    (flet ((valid-input (input) 
                (let ((parsed-output (parse-integer input :junk-allowed t)))
                    (and parsed-output
                        (or (null test-fn) 
                            (funcall test-fn parsed-output))))

                ))
    (let ((input ""))
        (loop while (not (valid-input input))
            do
            (format *standard-output* prompt)
            (force-output *standard-output*)
            (setf input (read-line *standard-input*)))
        (parse-integer input :junk-allowed t))
    ))
@

Later on, we are going to turn control over to the +play-game+ method.
The method we are providing for the UI to update based on game events
is to

==== Event Handlers ====

<<utility functions>>=
(defun take-blind-prompt (player)
    (format *standard-output* 
            "~A~%~A: Would you like to take the blind? [Y/N] > "
            (print-hand player)
            (sheepshead:name player))
    (read-line *standard-input*))
@

To display a player's full hand, we will duck tape in an additional
method, +print-hand+ which, as it implies, will print out every 

<<utility functions>>=
(defmethod print-hand ((player sheepshead:player))
    (let ((output-stream (make-string-output-stream)))
        (loop for card across (sheepshead:hand player)
            do (format output-stream " ~A " card))
        (get-output-stream-string output-stream)
        ))
@

==== Packaging ====

At the moment, the only packaging we are concerned with is an ASDF
package:

<<sheepshead-consoleui.asd>>=
(defpackage #:sheepshead-consoleui
    (:use :cl :asdf))

(defsystem sheepshead-consoleui
    :version 0.1
    :author "Michael McDermott"
    :license "BSD"
    :description "A Console UI for Sheepshead"
    :depends-on (:sheepshead)
    :components ((:file "consoleui")))
@

Conclusion
----------

In the future, more interfaces would be nice. Especially a graphical one.

Index
-----
