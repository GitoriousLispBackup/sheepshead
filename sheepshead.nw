Sheepshead - A Card Game
========================
Michael McDermott <mmcdermott@mad-computer-scientist.com>

Introduction
------------

Sheepshead is a German-American game played mostly in Wisconsin and
Minnesota. Outside of this geographic region, few people seem to
recognize it. As such, there are very few video game implementations
available and even fewer that run on good old Linux. The available
options are:

* Yahoo! Games. Maybe my reason for discounting it will sound like
  sour grapes, but I was unable to ever play a game. When I joined a
  table, the owner always booted me and when I opened a table, no one
  joined.
* schafKopf. This game has not been updated to KDE/Qt4 and does not
  seem to have any recent activity. Finally, when I went to the effort
  to dredge up KDE 3 libraries, it turned out to be quite different
  than the game I learned and loved.
* A couple of shareware options for Windows. Need I say more?

Our objectives are to create a Sheepshead game with the following
properties:

. The rules I grew up with (more on this later).
. Platform independence. At the very least, Windows and Linux. If a
Mac owner comes along, I would love to test for that platform as well.
. Core/UI separation. Eventually, multiple front ends would be ince.
In the immediacy, a simple Q/A-like console version will suffice.
. AI players.

This really does not seem like too much to ask for.

The rules we will be implementing can be found at Pagat
footnote:[http://www.pagat.com/schafk/shep.html]. The only major
caveat is that we will be implementing the Jack of Diamonds variant.

Core
----

This is where we model the basic elements of the game, including the
game itself. The interface should do little more than advance and
display the game in its own fashion. 

A Nice Game of Cards
~~~~~~~~~~~~~~~~~~~~

We will start at the bottom and build up. What is the most fundamental
thing in a card game? The cards. You cannot play without them, either
digitally or physically. The deck in Sheepshead is A-7 (i.e. 2-6s are
discarded) of each suit (assuming a French deck: clubs, spades,
hearts, and diamonds).

<<core.lisp>>=
(in-package :sheepshead)

(defconstant +LOWCARD+ 7)
(defconstant +HIGHCARD+ 14)
(defconstant +VERSION+ 0.1)
(defconstant +MINPLAYERS+ 3)
(defconstant +MAXPLAYERS+ 5)

(defclass card ()
    ((rank :accessor rank :initarg :rank)
     (suit :accessor suit :initarg :suit)))
@

Suits are assumed to be members of +'(:clubs :spades :hearts
:diamonds)+.
Rank must be between 7 and 14, inclusive. The card
corresponding to each number will start at 7 and follow the Germanic
ordering that Sheepshead uses. So, the following numbers would
correspond to the following cards:

.Card constants
|==============================
|Constant | Card
|7        | 7
|8        | 8
|9        | 9
|10       | King
|11       | 10
|12       | Ace
|13       | Jack
|14       | Queen
|==============================

The ordering may seem a little strange, but it should make sense with
knowledge of the rules because it allows rank comparison to be done
purely as +rank1 > rank2+. 

We will add an implementation of +print-object+ (See section 28.2 of
Common Lisp the Language; the equivalent of overriding C#'s toString()
method). Clearly, this will not suffice for the UI, but it will make
things much, much easier when debugging interactively.

<<core.lisp>>=
(defmethod print-object ((card card) stream)
    (let ((name (case (rank card)
                    (7 "7")
                    (8 "8")
                    (9 "9")
                    (10 "KING")
                    (11 "10")
                    (12 "ACE")
                    (13 "JACK")
                    (14 "QUEEN"))))
    (format stream "#<CARD ~A OF ~A>" name (suit card))))
@

This is little better than a C-struct in its current form. We have not
even bound the members. That is all right though. We will write a
function to generate a Sheepshead deck. The method used will be
extremely straightforward. For each suit, we will generate each of the
cards in the range 7-14. 

<<core.lisp>>=
(defmethod generate-deck ()
    (let ((deck (make-array '(32)))
          (index 0))
        (loop for suit in '(:clubs :spades :hearts :diamonds)
            do 
                (loop for rank from +LOWCARD+ upto +HIGHCARD+
                    do 
                    (setf (aref deck index) (make-instance 'card :rank rank :suit suit))
                    (setf index (+ index 1))
                    ))
         deck
    ))
@

We will provide another function, this one to shuffle the deck. The
algorithm used will be the Fisher-Yates Algorithm
footnote:[http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle].
From the above source, the pseudocode is:

    To shuffle an array a of n elements:
       for i from n - 1 downto 1 do
             j <- random integer with 0 <= j <= i
             exchange a[j] and a[i]

Our function will operate on an array, for efficiency's sake.
Accessing an array, in lisp, is constant time, but accessing the Nth
element of a list is O(n) time. So, to implmenet the above algorithm:

<<core.lisp>>=
(defmethod shuffle-deck ((deck array))
    (let ((deck-size 32))
        (loop for index from (- deck-size 1) downto 1
            do
                (let* ((random-index (random index))
                       (temp (aref deck random-index)))
                    (setf (aref deck random-index) (aref deck index))
                    (setf (aref deck index) temp)
                    ))
         deck
        ))
@

Players
~~~~~~~

With a shuffled pack of cards, the next step is to deal. To deal, we
need to have a game on, and to have a digital game on, we need to
model the game. So, let us do that.

Any player, regardless of whether they are human or AI controlled will
have a name, a hand, and a score (the game's running score, not the
points scored in a single hand).

<<core.lisp>>=
(defclass player ()
    ((name :accessor name :initarg :name :initform "Foo")
     (hand :accessor hand :initarg :hand :initform nil)
     (dealer? :accessor dealer? :initarg :dealer? :initform nil)
     (score :accessor score :initarg :score :initform 0)
    ))
@

Another basic is that all players must be able to return their card
selection for a given trick. While this function must be present, the
method chosen to pick the card will differ. For a player, the card
must be selected through the UI. For a bot, the card must be picked
using the proper algorithm.

<<core.lisp>>=
(defgeneric play-card (player trick))

(defgeneric take-blind? (player))
@

==== Human Controlled ====

A human controlled player will be like the basic one above in all
respects, save one. Namely, that its +play-card+ implementation must
get an answer from the UI. The easiest way to do this without tying
ourselves to any one is to provide a callback as a slot, and call it
when +play-card+ is called.

<<core.lisp>>=
(defclass human-player (player)
    ((play-callback :accessor play-callback :initarg play-callback)
     (blind-callback :accessor blind-callback :initarg blind-callback)
     ))

(defmethod play-card ((player human-player) trick)
    (funcall (play-callback player) trick))

(defmethod take-blind? ((player human-player))
    (funcall (blind-callback player)))
@

==== Bots ====

This is the problem with trying to write an artificial intelligence
for a game I've played almost as long as I can remember: I don't
really think much about why I play as I do. A lot of it revolves
around evaluating my own hand, watching other players' play, and
making deductions. Later on, I would like to program an AI that takes
advantage of information has it is revealed during the course of the
game--perhaps even tracking the other players' tendencies. 

For now, we are going to keep this very simple.

=== Games ===

We have cards and players. It is time to put it all together and play
a game. Sheepshead game goes through the following phases:

. Play a hand:
.. The cards are dealt to each player.
.. Starting at the dealer's left, each player is given the chance to
take the blind.
.. If a player takes the blind, he may bury a number of cards
equivalent to the size of the blind..
.. Tricks begin. The first trick is opened by the player to the
dealer's left.
.. Once all tricks have been played, the number of points is tallied
for each team.
. If the provided number of game points has not been reached, go to
step #1.

<<core.lisp>>=
(defclass game ()
    ((players :initarg :players :accessor players :initform nil)
     (goal-points :initarg :goal-points :accessor goal-points :initform 0)
     (hands :initarg :hands :accessor hands :initform nil)
     ))
@

A game, then, can be simulated with a very simple method. We will
first check the number of players. While some people claim that you
can play Sheepshead with less than three or more than five players,
they are wrong--they are heretics, may they be burnt at the stake. A
valid game will have 3-5 players, and will play the Jack of Diamonds
variant when five are playing.

The top level game, then, will follow this basic format:

. Verify that the number of players provided is accurate.
. Pass deal to the left (or, select the first dealer).
. Play a hand.
. Compare scores. If the game is over, return the winning player. If
not, go back to #1.

<<core.lisp>>=
(defmethod play-game ((game game))
    (let ((player-count (length (players game))))
        (if (and (>= player-count 3) (<= player-count 5))
            (progn <<play the game>>)
            (error "~A is the wrong number of players. There must be 3-5." player-count)
        )))
@

Items 2-4 of the above list find their implementation here. Step #2 is
pretty simple. Each

<<play the game>>=
@

and a hand:

<<core.lisp>>=
(defmethod play-hand ()
    )
@

Interfaces
----------

One of the primary objectives of this package was to allow plug 'n
play interfaces. So, there is no one single interface--except for now,
when I will implement only a single interface. The rest are strictly
TODO.

Console
~~~~~~~

The console interface is the simplest possible. It is to be the
Sheepshead equivalent of what happens when you type +gnuchess+ at the
command line. A simple, prompt-based interface. No ncurses, no
windowing, just a simple print out of game events and prompts for
input.

In the future, we will use libraries for other front ends (especially
the GUI). In order to prevent unneeded dependencies between them (i.e.
so that one could install the console version of sheepshead on a
headless box), we will keep the interface code in separate packages.

==== Initialization ====

We are going to create a simple +main+ function to kick everything
off. This will also serve as the entry point for +buildapp+ when we
create a binary.

The MO for this interface will be to:

. Print a welcome banner.
. Get player options and initialize the corresponding objects.
. Set up functions to handle game events.
. Let the game run itself.

To identify ourselves, we will print a nice little welcome banner. As
gaudy as you can get in plain text.

<<print banner>>=
(format *standard-output* "Sheepshead version ~A~%Copyright 2010 by Michael McDermott~%~%" sheepshead:+VERSION+)
@

To initialize the players, we need to get the number of players that
will be playing and set any other options (in this case, those options
are name and human vs. CPU control).

<<initialize players>>=
(let* ((player-count (get-number-of-players)))
    (print player-count)
    )
@

The function +get-number-of-players+ is separated out to keep the code
nice and neat. It doesn't really do anything surprising, just print
out a prompt, read in the data, and verify that it is valid.

<<utility functions>>=
(defun get-number-of-players ()
    (flet ((valid-input (input) 
                (let ((player-count (handler-case (parse-integer input :junk-allowed nil)
                    (sb-int:simple-parse-error (condition)
                            nil))))
                    (if (and (integerp player-count)
                             (>= player-count sheepshead:+MINPLAYERS+)
                             (<= player-count sheepshead:+MAXPLAYERS+))
                        t
                        nil))))
        (let ((input ""))
            (loop while (not (valid-input input))
                do
                (format *standard-output* "~&Please enter the number of players (3-5): ")
                (force-output *standard-output*)
                (setf input (read-line *standard-input*)))
            (parse-integer input :junk-allowed nil))
    ))
@

We can then put all of these pieces together, like so:

<<consoleui.lisp>>=
(in-package #:sheepshead-consoleui)

(defun main ()
    <<print banner>>
    <<initialize players>>
    <<wire up callbacks>>
    <<turn control over to game>>)

<<utility functions>>
@

==== Event Handlers ====

The +game+ class provides hooks for several callbacks. These are so
that the interface can insert its own logic.

==== Packaging ====

At the moment, the only packaging we are concerned with is an ASDF
package:

<<sheepshead-consoleui.asd>>=
(defpackage #:sheepshead-consoleui
    (:use :cl :asdf))

(defsystem sheepshead-consoleui
    :version 0.1
    :author "Michael McDermott"
    :license "BSD"
    :description "A Console UI for Sheepshead"
    :depends-on (:sheepshead)
    :components ((:file "consoleui")))
@

Packaging
---------

Like most Lisp systems, we will pacakge Sheepshead with ASDF. The
package should be straightforward.

<<sheepshead.asd>>=
(defpackage #:sheepshead
    (:export game player human-player card +VERSION+ +MINPLAYERS+ +MAXPLAYERS+)
    (:use :cl :asdf))

(defsystem sheepshead
    :version 0.1
    :author "Michael McDermott"
    :license "BSD"
    :description "Sheepshead"
    :components ((:file "core")))
@

Conclusion
----------

Index
-----
